---
title: Operating System -Chapter 3
commentable: false
date: 2023-02-16
modified: false
Edit: 2023-02-16
mathjax: true
mermaid: true
tags: Operating-System notes
categories: study notes
description: 操作系统学习笔记：调度算法 AND 死锁检测算法
status: Writing
---
# 数学符号（评价指标）
- $CPU利用率=\frac{忙时}{总时长}$
- $吞吐量 = \frac{总作业}{总时长}$
- $周转时间 = 完成时间-提交时间$
- $平均周转时间= \frac{各个作业周转时间之和}{作业数}$
- $带权周转时间 = \frac{周转时间}{实际运行时间}$
- $平均带权周转时间 = \frac{各个作业带权周转时间之和}{作业数}$


# 调度算法

## 先来先服务算法（FCFS）

### 基本思想

- 先来先服务作业调度
- 先来先服务进程调度

### 算法特点

- 优点：公平，实现简单
- 缺点：对于长作业有利，对于短作业则不利，因为可能由于长作业先到而导致短作业一直无法得到处理

## 短作业优先算法（SJF)

### 基本思想

- 最少的平均等待时间，最少的平均周转时间

### 算法特点

- 优点：最短的平均等待时间周转时间
- 缺点：对短作业有利，对长作业不利，因为有可能短作业太多导致长作业饥饿

## 高优先权优先调度算法

### 基本思想
- 照顾紧迫性作业

### 算法分类
- 非抢占式优先权算法
- 抢占式优先权算法

### 算法特点
- 优点：可以自行调整进程顺序
- 缺点：可能会导致饥饿

## 高相应比优先算法

$响应比 = \frac{等待时间+要求服务时间}{要求服务时间}$

### 基本思想
- 综合考虑

### 算法特点
- 综合考虑情况

## 时间片轮转算法

### 基本思想

- 先来先服务原则排队
- 时间片以及时钟中断

### 算法特点

- 优点：公平，响应快
- 缺点：进程切换有一定的开销

## 多级反馈队列算法

### 规则
- 设置多级就绪队列，队列优先级从高到低，时间片从小到大
- 新进程进入第一级，在时间片结束后进入下一级队列的队尾
- 只有当上一级队列为空的时候才给当前队列分配时间片

### 算法特点
- 平衡各种优缺点

## 死锁

### 产生条件

- 互斥： 对互斥使用的资源的争抢才会产生死锁
- 不剥夺条件：资源未适用之前不能夺走，只能主动释放
- 请求和保持：进程已经保持一个资源，又提出新的资源请求，但是该资源又被占
- 循环等待链：各个进程等待别的进程的资源，最后形成一个循环链

### 处理方法

- 预防死锁
- 避免死锁
- 检测和解除

### 预防死锁

1. 破坏不剥夺条件

    - 当进程请求的资源不满足时，立刻释放保持的资源
    - 某进程资源被其他资源占有的时候，通过操作系统进行剥夺
    - 缺点：
        - 实现复杂
        - 只适用于易于保存的资源
        - 增加开销
        - 可能会导致饥饿，因为资源会被剥夺

2. 破坏请求和保持条件

    - 运行前将所有的资源一次分配好
    - 缺点：资源利用率低

3. 破坏循环等待条件

    - 给资源进行编号，按照编号进行申请
    - 缺点：
        - 加设备的时候很难处理
        - 导致系统资源的浪费
        - 用户编程实现复杂麻烦
### 避免死锁（银行家算法）

*安全序列：系统按照这个序列分配资源，每个进程都可以顺利完成，如果分配后无安全序列，则系统进入了不安全状态*

> 银行家算法
```
/*
进程P申请资源request
此时系统有的资源是available
进程P还需要的资源是need
*/
if request > need 
    return false
if request > available
    //P进程应该等待

//试探满足P的需求

available = available - request //空闲的减少，因为被分配了
allocation = allocation + request //已经分配的增加
need = need - request   //need减少

//执行安全性算法检测是否安全

work = available 
finish = false
//在进程中找到满足finish=false即没有分配资源的，need<work即目前资源足够给他分配
for p in process:
    if p.finish = false and p.need < work
        work = work + allocation //将进程对应分配的资源归还
        p.finish = true

if finish = true //所有进程的finish都是真，则为安全序列
    return safe
else return not safe
```
### 死锁的检测和解除

*资源分配图*
<src="https://raw.githubusercontent.com/adoptedirelia/adoptedirelia.github.io/master/_posts/2023-02-06-OS/pic.png" width="30%"> 
